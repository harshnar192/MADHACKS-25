import WebSocket from "ws";
import type { TTSRequest } from "../../api/resources/textToSpeech/requests/TTSRequest.js";
export declare class StartEvent {
    readonly event = "start";
    readonly request: TTSRequest;
    constructor(request: TTSRequest);
    toJSON(): {
        event: string;
        request: TTSRequest;
    };
}
export declare class TextEvent {
    readonly event = "text";
    readonly text: string;
    constructor(text: string);
    toJSON(): {
        event: string;
        text: string;
    };
}
export declare class FlushEvent {
    readonly event = "flush";
    toJSON(): {
        event: string;
    };
}
export declare class CloseEvent {
    readonly event = "stop";
    toJSON(): {
        event: string;
    };
}
type WebSocketMessage = StartEvent | TextEvent | FlushEvent | CloseEvent;
/**
 * Events emitted by the RealtimeConnection.
 */
export declare enum RealtimeEvents {
    /** Emitted when audio chunk is received */
    AUDIO_CHUNK = "audio_chunk",
    /** Emitted when an error occurs */
    ERROR = "error",
    /** Emitted when the WebSocket connection is opened */
    OPEN = "open",
    /** Emitted when the WebSocket connection is closed */
    CLOSE = "close"
}
/**
 * Manages a real-time Text-to-Speech WebSocket connection.
 *
 * @remarks
 * **Node.js only**: This class uses Node.js-specific WebSocket implementation.
 *
 * @example
 * ```typescript
 * const connection = await client.textToSpeech.convertRealtime({
 *     request: TTSRequestOptions,
 *     text_stream: "...",
 *     model: "s1",
 * });
 *
 * connection.on(RealtimeEvents.OPEN, (data) => {
 *     console.log("WebSocket opened");
 * });
 *
 * connection.on(RealtimeEvents.AUDIO_CHUNK, (data) => {
 *     console.log("Audio chunk received");
 * });
 *
 * connection.on(RealtimeEvents.ERROR, (error) => {
 *     console.error("Error:", error);
 * });
 *
 * connection.on(RealtimeEvents.CLOSE, () => {
 *     console.log("WebSocket closed");
 * });
 * ```
 */
export declare class RealtimeConnection {
    private websocket;
    private eventEmitter;
    /**
     * @internal
     * Used internally by TextToSpeechWebSocket to attach the WebSocket after connection is created.
     */
    setWebSocket(websocket: WebSocket): void;
    /**
     * Attaches an event listener for the specified event.
     *
     * @param event - The event to listen for (use RealtimeEvents enum)
     * @param listener - The callback function to execute when the event fires
     *
     * @example
     * ```typescript
     * connection.on(RealtimeEvents.OPEN, (data) => {
     *     console.log("WebSocket opened");
     * });
     *
     * connection.on(RealtimeEvents.AUDIO_CHUNK, (data) => {
     *     console.log("Audio chunk received");
     * });
     *
     * connection.on(RealtimeEvents.ERROR, (error) => {
     *     console.error("Error:", error);
     * });
     *
     * connection.on(RealtimeEvents.CLOSE, () => {
     *     console.log("WebSocket closed");
     * });
     * ```
     */
    on(event: RealtimeEvents, listener: (...args: unknown[]) => void): void;
    /**
     * Removes an event listener for the specified event.
     *
     * @param event - The event to stop listening for
     * @param listener - The callback function to remove
     *
     * @example
     * ```typescript
     * const handler = (data) => console.log(data);
     * connection.on(RealtimeEvents.AUDIO_CHUNK, handler);
     *
     * // Later, remove the listener
     * connection.off(RealtimeEvents.AUDIO_CHUNK, handler);
     * ```
     */
    off(event: RealtimeEvents, listener: (...args: unknown[]) => void): void;
    /**
     * Sends a realtime message to the service.
     *
     * @throws {Error} If the WebSocket connection is not open
     */
    send(message: WebSocketMessage): void;
    /**
     * Closes the WebSocket connection and cleans up resources.
     * This will terminate any ongoing text-to-speech conversion.
     *
     * @remarks
     * After calling close(), this connection cannot be reused.
     * Create a new connection if you need to start converting again.
     *
     */
    close(): void;
}
export {};
